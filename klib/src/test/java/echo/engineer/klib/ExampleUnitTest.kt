package echo.engineer.klib

import org.junit.Test

/**
 * Example local unit test, which will execute on the development machine (host).
 *
 * See [testing documentation](http://d.android.com/tools/testing).
 */
class ExampleUnitTest {

    @Test
    fun addition_isCorrect() {
        val a = 4

        /**
         *  shl <<
         *  shr >>
         *  ushr >>>
         *  Java中 Integer 为32位有符号数 范围为 -2^31 ~ 2^31-1
         *  有符号数左移 二进制整体左移 低位补0
         *  4原二进制     0000 0000 0000 0000 0000 0000 0000 0100
         *  左移2位 得到  0000 0000 0000 0000 0000 0000 0001 0000
         *  所以结果为 16
         */

        println(a shl 2)//16
        println((a + 2) shl 2)//24
        println(a shr 2)//1
        println((a + 2) shr 2)//1
        println(a ushr 2)//1
        println((a + 2) ushr 2)//1


        /**
         * Java负数存储是以补码形式存储的（补码=反码+1）
         * 正数的反码和原码一致
         * 负数的反码除符号位以外 取反即可
         * 正数的补码与原码一致
         * 负数的补码=反码+1(末位+1)
         * 如 8 的原码：0000 0000 0000 0000 0000 0000 0000 1000
         * 负数的原码是：1.绝对值的二进制 2.最高位补1
         * 如 -8 绝对值的二进制 即是8的原码，所以 -8 的原码为
         * 1000 0000 0000 0000 0000 0000 0000 1000
         * 所以 -8 的反码为
         * 1111 1111 1111 1111 1111 1111 1111 0111
         * -8 的二进制表示为
         * 1111 1111 1111 1111 1111 1111 1111 1000
         * 左移二位：
         * 1111 1111 1111 1111 1111 1111 1110 0000
         * 还原成十进制 过程相反
         * 减1  : 1111 1111 1111 1111 1111 1111 1101 1111
         * 取反 : 1000 0000 0000 0000 0000 0000 0010 0000 (-32原码)
         * 去除符号位 0000 0000 0000 0000 0000 0000 0010 0000 (32原码)
         * 所以结果为-32
         *
         * 同理-6
         * 6原码   0000 0000 0000 0000 0000 0000 0000 0110
         * -6原码  1000 0000 0000 0000 0000 0000 0000 0110
         * -6反码  1111 1111 1111 1111 1111 1111 1111 1001
         * 二进制  1111 1111 1111 1111 1111 1111 1111 1010
         * 左移2位 1111 1111 1111 1111 1111 1111 1110 1000
         * 还原10进制 过程相反
         * 减一 1111 1111 1111 1111 1111 1111 1110 0111
         * 取反  1000 0000 0000 0000 0000 0000 0001 1000 即 -24
         */

        println("负数测试")
        val b = -8
        println(b shl 2)//-32
        println((b + 2) shl 2)//-24
        //1111 1111 1111 1111 1111 1111 1111 1000 ---> 1111 1111 1111 1111 1111 1111 1111 1110 ---> 1111 1111 1111 1111 1111 1111 1111 1101 ---> 1000 0000 0000 0000 0000 0000 0000 0010
        println(b shr 2)//-2
        //1111 1111 1111 1111 1111 1111 1111 1010 ---> 1111 1111 1111 1111 1111 1111 1111 1110
        println((b + 2) shr 2)//-2
        /**
         * 不管正数负数 无符号右移高位均补0
         */
        //1111 1111 1111 1111 1111 1111 1111 1000 ---> 0011 1111 1111 1111 1111 1111 1111 1110 ---> 1073741822
        println(b ushr 2)
        //1111 1111 1111 1111 1111 1111 1111 1010 ---> 0011 1111 1111 1111 1111 1111 1111 1110 ---> 1073741822
        println((b + 2) ushr 2)//1073741822

        /**
         * 交换两个数
         */
        var e = 10
        var f = 4
        println("before e=$e f=$f")
        val tmp = e
        e = f
        f = tmp
        println("after tmp e=$e f=$f")

        //在两个数相加或者相减仍然在int的范围内
        e = 10
        f = 4
        e = e + f // e=10+4=14
        f = e - f // f=10+4-4=10
        e = e - f // e=10+4-10=4
        println("after add e=$e f=$f")

        /**
         * 异或 ^ xor 特性
         * 1. 交换律 a^b = b^a
         * 2. 结合律 a^b^c = a^(b^c) = (a^b)^c
         * 3. 自反性 a^b^b=a
         *
         * 结合自反性可以实现数的交换
         */
        e = 10
        f = 4
        e = e xor f //e^f
        f = e xor f //e^f^f =e
        e = e xor f //e^f^e =f
        println("after xor e=$e f=$f")
    }
}
